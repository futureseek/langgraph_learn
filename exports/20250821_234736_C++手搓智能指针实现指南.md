# C++手搓智能指针实现指南

## 文档信息

- **内容长度**: 2007 字符
- **内容类型**: AI 生成内容

## 生成信息

- **生成时间**: 2025-08-21 23:47:36
- **生成工具**: LangGraph 聊天机器人

## 内容

## C++手搓智能指针实现指南

### 1. 智能指针基本概念

智能指针是模拟指针动作的类，它通过重载`->`和`*`运算符来模拟原始指针的行为。智能指针的主要目的是自动管理内存，防止内存泄漏。

### 2. 智能指针的类型

#### unique_ptr（专属所有权）
- 独占对象的所有权
- 不允许复制，但可以移动
- 对象在unique_ptr销毁时自动删除

#### shared_ptr（共享所有权）
- 多个shared_ptr可以指向同一个对象
- 使用引用计数跟踪有多少个shared_ptr共享同一指针
- 当最后一个shared_ptr销毁时，对象被自动删除

#### weak_ptr（弱引用）
- 与shared_ptr配合使用
- 不增加引用计数
- 用于解决循环引用问题

### 3. 手搓智能指针的实现要点

#### 基本实现步骤：
1. 将智能指针声明为自动（局部）变量
2. 在类型参数中指定封装指针的指向类型
3. 在智能指针构造函数中将原始指针传递给new对象
4. 使用重载的`->`和`*`运算符访问对象
5. 允许智能指针自动删除对象

#### 实现示例（简化版unique_ptr）：
```cpp
template<typename T>
class SimpleUniquePtr {
private:
    T* ptr;
    
public:
    // 构造函数
    explicit SimpleUniquePtr(T* p = nullptr) : ptr(p) {}
    
    // 析构函数
    ~SimpleUniquePtr() {
        delete ptr;
    }
    
    // 禁止拷贝构造和拷贝赋值
    SimpleUniquePtr(const SimpleUniquePtr&) = delete;
    SimpleUniquePtr& operator=(const SimpleUniquePtr&) = delete;
    
    // 支持移动构造和移动赋值
    SimpleUniquePtr(SimpleUniquePtr&& other) noexcept : ptr(other.ptr) {
        other.ptr = nullptr;
    }
    
    SimpleUniquePtr& operator=(SimpleUniquePtr&& other) noexcept {
        if (this != &other) {
            delete ptr;
            ptr = other.ptr;
            other.ptr = nullptr;
        }
        return *this;
    }
    
    // 重载解引用运算符
    T& operator*() const {
        return *ptr;
    }
    
    // 重载箭头运算符
    T* operator->() const {
        return ptr;
    }
    
    // 获取原始指针
    T* get() const {
        return ptr;
    }
    
    // 释放所有权
    T* release() {
        T* temp = ptr;
        ptr = nullptr;
        return temp;
    }
    
    // 重置指针
    void reset(T* p = nullptr) {
        delete ptr;
        ptr = p;
    }
};
```

### 4. 使用注意事项

1. 始终在单独的代码行上创建智能指针，不要在参数列表中创建
2. 避免使用裸指针，除非在特定场景下需要（如函数内部临时使用）
3. 理解不同智能指针的使用场景：
   - unique_ptr：独占所有权的场景
   - shared_ptr：需要共享所有权的场景
   - weak_ptr：解决循环引用问题

### 5. 最佳实践

1. 优先使用unique_ptr，只有在确实需要共享所有权时才使用shared_ptr
2. 函数参数设计时考虑所有权和生命周期：
   - 仅使用对象：使用原始指针或const引用
   - 需要保存智能指针：直接传值并使用move语义
3. 理解对象所有权概念，正确管理对象生命周期